// Workaround rustfmt bug:
// https://github.com/rust-lang/rustfmt/issues/3794
#[path = "common.rs"]
mod common;

use allsorts::binary::read::ReadScope;
use allsorts::error::ParseError;
use allsorts::woff::WoffFile;

use crate::common::read_fixture;

fn metadata() -> String {
    std::fs::read_to_string("tests/fonts/woff1/metadata.xml")
        .expect("unable to read tests/fonts/woff1/metadata.xml")
        .trim()
        .to_string()
}

// These test cases use test files generated by the W3C WOFF test suite:
// https://github.com/w3c/woff/tree/de2b2b3f9a16feccd965255576efc7c1c6443a63/woff1/tests/Format

// Valid CFF flavored WOFF with no metadata and no private data
#[test]
fn test_valid001() {
    let buffer = read_fixture("tests/fonts/woff1/valid-001.woff");
    let result = ReadScope::new(&buffer).read::<WoffFile>().unwrap();

    assert_eq!(result.flavor(), allsorts::tables::CFF_MAGIC);
    assert_eq!(result.extended_metadata().unwrap(), None);
    assert_eq!(result.table_directory.len(), 9);
}

// Valid CFF flavored WOFF with metadata
#[test]
fn test_valid002() {
    let buffer = read_fixture("tests/fonts/woff1/valid-002.woff");
    let result = ReadScope::new(&buffer).read::<WoffFile>().unwrap();

    assert_eq!(result.flavor(), allsorts::tables::CFF_MAGIC);
    assert_eq!(result.extended_metadata().unwrap(), Some(metadata()));
    assert_eq!(result.table_directory.len(), 9);
}

// Valid TTF flavored WOFF with no metadata and no private data
#[test]
fn test_valid005() {
    let buffer = read_fixture("tests/fonts/woff1/valid-005.woff");
    let result = ReadScope::new(&buffer).read::<WoffFile>().unwrap();

    assert_eq!(result.flavor(), allsorts::tables::TTF_MAGIC);
    assert_eq!(result.extended_metadata().unwrap(), None);
    assert_eq!(result.table_directory.len(), 11);
}

// Valid TTF flavored WOFF with metadata
#[test]
fn test_valid006() {
    let buffer = read_fixture("tests/fonts/woff1/valid-006.woff");
    let result = ReadScope::new(&buffer).read::<WoffFile>().unwrap();

    assert_eq!(result.flavor(), allsorts::tables::TTF_MAGIC);
    assert_eq!(result.extended_metadata().unwrap(), Some(metadata()));
    assert_eq!(result.table_directory.len(), 11);
}

// Header Reserved Invalid Value: The reserved field contains 1.
#[test]
fn test_header_reserved001() {
    let buffer = read_fixture("tests/fonts/woff1/header-reserved-001.woff");
    let result = ReadScope::new(&buffer).read::<WoffFile>();

    match result {
        Ok(_) => panic!("expected Err got Ok"),
        Err(ParseError::BadValue) => (),
        Err(err) => panic!("expected ParseError::BadValue got {:?}", err),
    }
}

// Font Table Data Offset Past End of File: The offset to the final table is four bytes beyond the
// end of the file.
#[test]
fn test_directory_overlaps_001() {
    let buffer = read_fixture("tests/fonts/woff1/directory-overlaps-001.woff");
    let woff_file = ReadScope::new(&buffer).read::<WoffFile>().unwrap();

    let result = woff_file
        .table_directory
        .iter()
        .map(|entry| entry.read_table(&woff_file.scope))
        .collect::<Result<Vec<_>, _>>();

    match result {
        Ok(_) => panic!("expected Err got Ok"),
        Err(ParseError::BadOffset) => (),
        Err(err) => panic!("expected ParseError::BadOffset got {:?}", err),
    }
}

// Font Table Data Invalid Compressed Data: One compressed table has had its compressed data
// replaced with \01 making it incompatible with zlib.
#[test]
fn test_tabledata_zlib_001() {
    let buffer = read_fixture("tests/fonts/woff1/tabledata-zlib-001.woff");
    let woff_file = ReadScope::new(&buffer).read::<WoffFile>().unwrap();

    let result = woff_file
        .table_directory
        .iter()
        .map(|entry| entry.read_table(&woff_file.scope))
        .collect::<Result<Vec<_>, _>>();

    match result {
        Ok(_) => panic!("expected Err got Ok"),
        Err(ParseError::CompressionError) => (),
        Err(err) => panic!("expected ParseError::CompressionError got {:?}", err),
    }
}
