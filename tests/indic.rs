mod common;

use std::io::BufRead;
use std::path::Path;
use std::rc::Rc;

use lazy_static::lazy_static;
use regex::Regex;

use allsorts::binary::read::ReadScope;
use allsorts::error::{ParseError, ShapingError};
use allsorts::font_data_impl::FontDataImpl;
use allsorts::gsub::{gsub_apply_default, GlyphOrigin, RawGlyph};
use allsorts::indic;
use allsorts::tables::cmap::CmapSubtable;
use allsorts::tables::{FontTableProvider, OpenTypeFile};
use allsorts::tag;

// Variant of `bin/shape::shape_ttf`
fn shape_ttf_indic<'a, T: FontTableProvider>(
    font: &mut FontDataImpl<T>,
    script: u32,
    lang: u32,
    text: &str,
) -> Result<Vec<u16>, ShapingError> {
    let cmap_subtable_data = font.cmap_subtable_data().to_vec();
    let cmap_subtable = ReadScope::new(&cmap_subtable_data)
        .read::<CmapSubtable<'_>>()
        .expect("no suitable cmap subtable");

    // Run Indic-specific decomposition and recomposition prior to shaping
    let mut chars = text.chars().collect();
    indic::preprocess_indic(&mut chars);

    let opt_glyphs_res: Result<Vec<_>, _> = chars
        .iter()
        .map(|ch| map_glyph(&cmap_subtable, *ch))
        .collect();
    let mut opt_glyphs = opt_glyphs_res?;

    // Mimic the existing behaviour of Prince, which is to split a sequence if
    // a font is missing a character glyph. We previously copied the behaviour
    // in `shape.rs`, where the missing glyphs are merely omitted. This can be
    // misleading, especially when comparing the glyph indices as generated by
    // the corpus test against the PDF as generated by Prince.
    //
    // Example:
    //   Assumptions:
    //     1. A and B can form a ligature A+B iff D is base.
    //     2. A+B and C can form a ligature A+B+C iff D is base.
    //
    //   Test sequence: [A, B, Missing, C, D]
    //          Prince: [A, B] [Missing] [C, D] - No ligation. The sequence is split, and
    //                                            D is no longer the base of A and B
    //        shape.rs: [A+B+C, D] - Unexpected ligature; doesn't match Prince's PDF output
    let mut glyphs: Vec<Vec<RawGlyph<()>>> = Vec::new();
    while !opt_glyphs.is_empty() {
        let mut i = 0;
        while let Some(Some(_)) = opt_glyphs.get(i) {
            i += 1;
        }

        let sub_sequence = opt_glyphs.drain(..i).flatten().collect();
        glyphs.push(sub_sequence);

        if !opt_glyphs.is_empty() {
            opt_glyphs.remove(0);
        }
    }

    let gsub_cache = font
        .gsub_cache()
        .expect("unable to get gsub cache")
        .expect("missing gsub table");
    let opt_gdef_table = font.gdef_table().expect("unable to get gdef table");
    let vertical = false;

    for mut gs in glyphs.iter_mut() {
        gsub_apply_default(
            &|| make_dotted_circle(&cmap_subtable),
            &gsub_cache,
            opt_gdef_table.as_ref().map(Rc::as_ref),
            script,
            lang,
            vertical,
            &mut gs,
        )?;
    }

    let glyph_indices = glyphs
        .into_iter()
        .flatten()
        .map(|g| g.glyph_index.unwrap_or(0)) // Set to 0 if `None`, but shouldn't happen
        .collect();

    Ok(glyph_indices)
}

// Copy of `bin/shape::make_dotted_circle`
fn make_dotted_circle(cmap_subtable: &CmapSubtable) -> Vec<RawGlyph<()>> {
    match map_glyph(cmap_subtable, '\u{25CC}') {
        Ok(Some(raw_glyph)) => vec![raw_glyph],
        _ => Vec::new(),
    }
}

// Variant of `bin/shape::map_glyph`
fn map_glyph(cmap_subtable: &CmapSubtable, ch: char) -> Result<Option<RawGlyph<()>>, ParseError> {
    // Specially handle ZWNJ character, so as to mimic existing Prince behaviour
    if ch == '\u{200C}' {
        Ok(Some(make_zwnj()))
    } else {
        cmap_subtable
            .map_glyph(ch as u32)
            .map(|opt_index| opt_index.map(|index| make_glyph(ch, index)))
    }
}

// Copy of `bin/shape::make_glyph`
fn make_glyph(ch: char, glyph_index: u16) -> RawGlyph<()> {
    RawGlyph {
        unicodes: vec![ch],
        glyph_index: Some(glyph_index),
        liga_component_pos: 0,
        glyph_origin: GlyphOrigin::Char(ch),
        small_caps: false,
        multi_subst_dup: false,
        is_vert_alt: false,
        fake_bold: false,
        fake_italic: false,
        extra_data: (),
    }
}

fn make_zwnj() -> RawGlyph<()> {
    RawGlyph {
        unicodes: vec![],
        glyph_index: None,
        liga_component_pos: 0,
        glyph_origin: GlyphOrigin::Char('\u{200C}'),
        small_caps: false,
        multi_subst_dup: false,
        is_vert_alt: false,
        fake_bold: false,
        fake_italic: false,
        extra_data: (),
    }
}

fn read_fixture_test_inputs<P: AsRef<Path>>(path: P) -> Vec<u8> {
    common::read_fixture(Path::new("tests/indic").join(path))
}

fn read_fixture_test_font<P: AsRef<Path>>(path: P) -> Vec<u8> {
    common::read_fixture(Path::new("../../../data/fonts").join(path))
}

fn read_inputs<P: AsRef<Path>>(inputs_path: P) -> Vec<String> {
    read_fixture_test_inputs(inputs_path)
        .lines()
        .collect::<Result<_, _>>()
        .expect("error reading inputs")
}

fn parse_expected_output(expected_output: &str, ignore: &[u16]) -> (Vec<u16>, Option<String>) {
    fn parse(s: &str, ignore: &[u16]) -> Vec<u16> {
        s.split("|")
            .map(|s| s.parse::<u16>().expect("error parsing glyph index"))
            .filter(|i| ignore.is_empty() || !ignore.contains(i))
            .collect()
    }

    lazy_static! {
        static ref REGEX: Regex = Regex::new(r"^\[(\d+(?:\|\d+)*)\](?:\s*:\s*(.*))?$").unwrap();
    }

    if let Some(captures) = REGEX.captures(expected_output) {
        let indices = parse(&captures[1], ignore);
        let reason = captures.get(2).map(|s| String::from(s.as_str()));

        (indices, reason)
    } else {
        panic!("invalid expected output format: {:?}", expected_output);
    }
}

fn parse_expected_outputs<P: AsRef<Path>>(
    expected_outputs_path: P,
    ignore: &[u16],
) -> Vec<(Vec<u16>, Option<String>)> {
    read_fixture_test_inputs(expected_outputs_path)
        .lines()
        .map(|line| line.expect("error reading expected output"))
        .map(|line| parse_expected_output(&line, ignore))
        .collect()
}

fn run_test<P: AsRef<Path>>(
    inputs_path: P,
    expected_outputs_path: P,
    font_path: P,
    script_tag: &str,
    lang_tag: &str,
    ignore: &[u16],
    expected_num_fail: usize,
) {
    let inputs = read_inputs(inputs_path);
    let expected_outputs = parse_expected_outputs(expected_outputs_path, ignore);
    assert_eq!(expected_outputs.len(), inputs.len());

    let font_buffer = read_fixture_test_font(font_path);
    let opentype_file = ReadScope::new(&font_buffer)
        .read::<OpenTypeFile<'_>>()
        .unwrap();
    let font_table_provider = opentype_file
        .font_provider(0)
        .expect("error reading font file");
    let mut font = FontDataImpl::new(Box::new(font_table_provider))
        .expect("error reading font data")
        .expect("missing required font tables");

    let script = tag::from_string(script_tag).expect("invalid script tag");
    let lang = tag::from_string(lang_tag).expect("invalid language tag");

    let mut num_pass = 0;
    let mut num_fail = 0;
    for (i, input) in inputs.iter().enumerate() {
        let shaped = shape_ttf_indic(&mut font, script, lang, &input);

        match (&shaped, &expected_outputs[i]) {
            (Ok(output), (expected_output, opt_reason)) if output == expected_output => {
                // If a successful test has a (failure) reason attached,
                // we may want to know about it
                if let Some(reason) = opt_reason {
                    println!("[SUCCESS]");
                    println!("line {:0>5}: {}", i + 1, input);
                    println!("    reason: {}", reason);
                    println!();
                }

                num_pass += 1;
            }
            (result, (expected_output, opt_reason)) => {
                println!("line {:0>5}: {}", i + 1, input);
                println!("  harfbuzz: {:?}", expected_output);
                match result {
                    Ok(output) => println!("    prince: {:?}", output),
                    Err(error) => println!("    prince: {:?}", error),
                };
                if let Some(reason) = opt_reason {
                    println!("    reason: {}", reason);
                }
                println!();

                num_fail += 1;
            }
        }
    }

    println!("total: {:?}", inputs.len());
    println!(" pass: {:?}", num_pass);
    println!(" fail: {:?}", num_fail);

    assert_eq!(num_pass + num_fail, inputs.len());
    assert_eq!(num_fail, expected_num_fail);
}

fn run_test_bad<P: AsRef<Path>>(inputs_path: P, font_path: P, script_tag: &str, lang_tag: &str) {
    let inputs = read_inputs(inputs_path);

    let font_buffer = read_fixture_test_font(font_path);
    let opentype_file = ReadScope::new(&font_buffer)
        .read::<OpenTypeFile<'_>>()
        .unwrap();
    let font_table_provider = opentype_file
        .font_provider(0)
        .expect("error reading font file");
    let mut font = FontDataImpl::new(Box::new(font_table_provider))
        .expect("error reading font data")
        .expect("missing required font tables");
    let script = tag::from_string(script_tag).expect("invalid script tag");
    let lang = tag::from_string(lang_tag).expect("invalid language tag");

    for input in inputs.iter() {
        let _shaped = shape_ttf_indic(&mut font, script, lang, &input);
    }
}

// Run with `-- --nocapture` to view details of failed test cases
#[cfg(test)]
mod tests {
    use super::*;

    // HarfBuzz replaces joiner glyphs with the space glyph, which we
    // omit from the output comparisons as our (current) approach is
    // different (we strip all joiners from the glyph buffer after GSUB)
    const JOINER_GLYPH_INDEX: u16 = 3;

    mod devanagari {
        use super::*;

        const INPUT: &str = "good.hi";
        const SCRIPT_TAG: &str = "deva";
        const LANG_TAG: &str = "HIN";

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.hi",
                    "devanagari/lohit_hi.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    32,
                );
            }

            #[test]
            fn test_mangal() {
                run_test(
                    INPUT,
                    "harfbuzz/good-mangal.hi",
                    "devanagari/mangal.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    84,
                );
            }

            #[test]
            fn test_sahadeva() {
                run_test(
                    INPUT,
                    "harfbuzz/good-sahadeva.hi",
                    "devanagari/sahadeva.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    84,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_annapurna() {
                run_test(
                    INPUT,
                    "harfbuzz/good-annapurna.hi",
                    "devanagari/AnnapurnaSIL-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    6,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    INPUT,
                    "harfbuzz/good-nirmala.hi",
                    "indic/Nirmala.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    35,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.hi",
                    "noto/NotoSansDevanagari-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    9,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-serif.hi",
                    "noto/NotoSerifDevanagari-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    29,
                );
            }
        }
    }

    mod bengali {
        use super::*;

        const INPUT: &str = "good.bn";
        const SCRIPT_TAG: &str = "beng";
        const LANG_TAG: &str = "BEN";

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.bn",
                    "bengali/Lohit-Bengali.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    25,
                );
            }

            #[test]
            fn test_siyam() {
                run_test(
                    INPUT,
                    "harfbuzz/good-siyam.bn",
                    "bengali/Siyamrupali_1_01.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    28,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.bn",
                    "noto/NotoSansBengali-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    12,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-serif.bn",
                    "noto/NotoSerifBengali-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    9,
                );
            }
        }
    }

    mod gurmukhi {
        use super::*;

        const INPUT: &str = "good.pa";
        const SCRIPT_TAG: &str = "guru";
        const LANG_TAG: &str = "PAN";

        mod indic1 {
            use super::*;

            #[test]
            fn test_saab() {
                run_test(
                    INPUT,
                    "harfbuzz/good-saab.pa",
                    "gurmukhi/Saab.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    58,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            // High number of failures due to the following issue:
            // https://github.com/n8willis/opentype-shaping-documents/issues/71
            fn test_nirmala() {
                run_test(
                    INPUT,
                    "harfbuzz/good-nirmala.pa",
                    "indic/Nirmala.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    372,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.pa",
                    "noto/NotoSansGurmukhi-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    4,
                );
            }

            #[test]
            fn test_raavi() {
                run_test(
                    INPUT,
                    "harfbuzz/good-raavi.pa",
                    "gurmukhi/raavi.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    45,
                );
            }
        }
    }

    mod gujarati {
        use super::*;

        const INPUT: &str = "good.gu";
        const SCRIPT_TAG: &str = "gujr";
        const LANG_TAG: &str = "GUJ";

        // Both Padmaa and Rekha lack the ZWJ glyph, which means that a
        // significant number of failures occur (see comment in `shape_ttf_indic`
        // regarding Prince's splitting of syllable sequences)
        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.gu",
                    "gujarati/lohit_gu.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    15,
                );
            }

            #[test]
            fn test_padmaa() {
                // A fair number of syllables in the Gujarati corpus make use
                // of glyphs that the Padmaa font lacks:
                //
                //   * Sign Vocalic L - 88 syllables
                //   * Devanagari Udatta - 6 syllables
                //   * Devanagari Anudatta - 3 syllables
                //
                // For now, just ignore these glyphs when comparing the outputs
                let missing_glyph_index = 0;

                run_test(
                    INPUT,
                    "harfbuzz/good-padmaa.gu",
                    "gujarati/padmaa.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[missing_glyph_index, JOINER_GLYPH_INDEX],
                    550,
                );
            }

            #[test]
            fn test_rekha() {
                run_test(
                    INPUT,
                    "harfbuzz/good-rekha.gu",
                    "gujarati/Rekha.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    558,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.gu",
                    "noto/NotoSansGujarati-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    12,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-serif.gu",
                    "noto/NotoSerifGujarati-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    35,
                );
            }

            // Large number of failures due to the lack of ZWJ and
            // dotted circle glyphs
            #[test]
            fn test_samyak() {
                run_test(
                    INPUT,
                    "harfbuzz/good-samyak.gu",
                    "gujarati/Samyak-Gujarati.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    625,
                );
            }
        }
    }

    mod oriya {
        use super::*;

        const INPUT: &str = "good.or";
        const SCRIPT_TAG: &str = "orya";
        const LANG_TAG: &str = "ORI";

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.or",
                    "oriya/lohit_or.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    25,
                );
            }

            // Much like Gujarati's Padmaa and Rekha, the lack of a ZWJ
            // glyph means a large number of failures occur
            #[test]
            fn test_ori1uni() {
                run_test(
                    INPUT,
                    "harfbuzz/good-ori1uni.or",
                    "oriya/utkalm.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    147,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_kalinga() {
                run_test(
                    INPUT,
                    "harfbuzz/good-kalinga.or",
                    "oriya/kalinga.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    51,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    INPUT,
                    "harfbuzz/good-nirmala.or",
                    "indic/Nirmala.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    14,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.or",
                    "noto/NotoSansOriya-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    36,
                );
            }
        }
    }

    mod tamil {
        use super::*;

        const INPUT: &str = "good.ta";
        const SCRIPT_TAG: &str = "taml";
        const LANG_TAG: &str = "TAM";

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.ta",
                    "tamil/lohit_ta.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            // Missing glyphs, including the dotted circle
            #[test]
            fn test_tamu() {
                run_test(
                    INPUT,
                    "harfbuzz/good-tamu.ta",
                    "tamil/TAMu_Kalyani.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    167,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_latha() {
                // Latha doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 202;

                run_test(
                    INPUT,
                    "harfbuzz/good-latha.ta",
                    "tamil/latha.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[joiner_glyph_index],
                    1,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    INPUT,
                    "harfbuzz/good-nirmala.ta",
                    "indic/Nirmala.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.ta",
                    "noto/NotoSansTamil-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-serif.ta",
                    "noto/NotoSerifTamil-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }
    }

    mod telugu {
        use super::*;

        const INPUT: &str = "good.te";
        const SCRIPT_TAG: &str = "telu";
        const LANG_TAG: &str = "TEL";

        mod indic1 {
            use super::*;

            // Failures are largely due to a handful of missing glyphs
            #[test]
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.te",
                    "telugu/lohit_te.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    93,
                );
            }
        }

        mod indic2 {
            use super::*;

            // Failures are largely due to a handful of missing glyphs
            #[test]
            fn test_gautami() {
                run_test(
                    INPUT,
                    "harfbuzz/good-gautami.te",
                    "telugu/gautami.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    94,
                );
            }

            #[test]
            fn test_mandali() {
                run_test(
                    INPUT,
                    "harfbuzz/good-mandali.te",
                    "telugu/Mandali-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    10,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    INPUT,
                    "harfbuzz/good-nirmala.te",
                    "indic/Nirmala.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    7,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.te",
                    "noto/NotoSansTelugu-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    17,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-serif.te",
                    "noto/NotoSerifTelugu-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    16,
                );
            }
        }
    }

    mod kannada {
        use super::*;

        const INPUT: &str = "good.kn";
        const SCRIPT_TAG: &str = "knda";
        const LANG_TAG: &str = "KAN";

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.kn",
                    "kannada/lohit_kn.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    118,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    INPUT,
                    "harfbuzz/good-nirmala.kn",
                    "indic/Nirmala.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    104,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.kn",
                    "noto/NotoSansKannada-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    79,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-serif.kn",
                    "noto/NotoSerifKannada-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    81,
                );
            }

            #[test]
            fn test_tunga() {
                run_test(
                    INPUT,
                    "harfbuzz/good-tunga.kn",
                    "kannada/tunga.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    90,
                );
            }
        }
    }

    mod malayalam {
        use super::*;

        const INPUT: &str = "good.ml";
        const SCRIPT_TAG: &str = "mlym";
        const LANG_TAG: &str = "MAL";

        mod indic1 {
            use super::*;

            #[test]
            // High number of failures due to the following issue:
            // https://github.com/n8willis/opentype-shaping-documents/issues/71
            fn test_lohit() {
                run_test(
                    INPUT,
                    "harfbuzz/good-lohit.ml",
                    "malayalam/lohit_ml.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    97,
                );
            }

            #[test]
            fn test_rachana() {
                // Indic1 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    INPUT,
                    "harfbuzz/good-rachana-indic1.ml",
                    "malayalam/Rachana_w01.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[joiner_glyph_index],
                    11,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_chilanka() {
                // Chilanka doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 2;

                run_test(
                    INPUT,
                    "harfbuzz/good-chilanka.ml",
                    "malayalam/Chilanka-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[joiner_glyph_index],
                    10,
                );
            }

            #[test]
            fn test_dyuthi() {
                // Dyuthi doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    INPUT,
                    "harfbuzz/good-dyuthi.ml",
                    "malayalam/Dyuthi-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[joiner_glyph_index],
                    44,
                );
            }

            #[test]
            // High number of failures, due to differences in pre-base
            // matra / reordering consonant final positions. However, our
            // output is (visually) _almost_ identical to Uniscribe's.
            // Only three tests differ: 6570, 6571, 12522
            fn test_nirmala() {
                run_test(
                    INPUT,
                    "harfbuzz/good-nirmala.ml",
                    "indic/Nirmala.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    380,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-sans.ml",
                    "noto/NotoSansMalayalam-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    150,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    INPUT,
                    "harfbuzz/good-noto-serif.ml",
                    "noto/NotoSerifMalayalam-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[JOINER_GLYPH_INDEX],
                    16,
                );
            }

            #[test]
            fn test_rachana() {
                // Indic2 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    INPUT,
                    "harfbuzz/good-rachana-indic2.ml",
                    "malayalam/Rachana-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                    &[joiner_glyph_index],
                    15,
                );
            }
        }
    }

    mod bad {
        use super::*;

        mod devanagari {
            use super::*;

            const INPUT: &str = "bad.hi";
            const SCRIPT_TAG: &str = "deva";
            const LANG_TAG: &str = "HIN";

            #[test]
            fn test_annapurna() {
                run_test_bad(
                    INPUT,
                    "devanagari/AnnapurnaSIL-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "devanagari/lohit_hi.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_mangal() {
                run_test_bad(INPUT, "devanagari/mangal.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_sahadeva() {
                run_test_bad(INPUT, "devanagari/sahadeva.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_nirmala() {
                run_test_bad(INPUT, "indic/Nirmala.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansDevanagari-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSerifDevanagari-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }
        }

        mod bengali {
            use super::*;

            const INPUT: &str = "bad.bn";
            const SCRIPT_TAG: &str = "beng";
            const LANG_TAG: &str = "BEN";

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "bengali/Lohit-Bengali.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_siyam() {
                run_test_bad(INPUT, "bengali/Siyamrupali_1_01.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansBengali-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSerifBengali-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }
        }

        mod gurmukhi {
            use super::*;

            const INPUT: &str = "bad.pa";
            const SCRIPT_TAG: &str = "guru";
            const LANG_TAG: &str = "PAN";

            #[test]
            fn test_saab() {
                run_test_bad(INPUT, "gurmukhi/Saab.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_nirmala() {
                run_test_bad(INPUT, "indic/Nirmala.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansGurmukhi-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_raavi() {
                run_test_bad(INPUT, "gurmukhi/raavi.ttf", SCRIPT_TAG, LANG_TAG);
            }
        }

        mod gujarati {
            use super::*;

            const INPUT: &str = "bad.gu";
            const SCRIPT_TAG: &str = "gujr";
            const LANG_TAG: &str = "GUJ";

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "gujarati/lohit_gu.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_padmaa() {
                run_test_bad(INPUT, "gujarati/padmaa.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_samyak() {
                run_test_bad(INPUT, "gujarati/Samyak-Gujarati.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_rekha() {
                run_test_bad(INPUT, "gujarati/Rekha.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansGujarati-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSerifGujarati-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }
        }

        mod oriya {
            use super::*;

            const INPUT: &str = "bad.or";
            const SCRIPT_TAG: &str = "orya";
            const LANG_TAG: &str = "ORI";

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "oriya/lohit_or.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_ori1uni() {
                run_test_bad(INPUT, "oriya/utkalm.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_kalinga() {
                run_test_bad(INPUT, "oriya/kalinga.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_nirmala() {
                run_test_bad(INPUT, "indic/Nirmala.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansOriya-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }
        }

        mod tamil {
            use super::*;

            const INPUT: &str = "bad.ta";
            const SCRIPT_TAG: &str = "taml";
            const LANG_TAG: &str = "TAM";

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "tamil/lohit_ta.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_tamu() {
                run_test_bad(INPUT, "tamil/TAMu_Kalyani.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_latha() {
                run_test_bad(INPUT, "tamil/latha.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_nirmala() {
                run_test_bad(INPUT, "indic/Nirmala.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansTamil-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSerifTamil-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }
        }

        mod telugu {
            use super::*;

            const INPUT: &str = "bad.te";
            const SCRIPT_TAG: &str = "telu";
            const LANG_TAG: &str = "TEL";

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "telugu/lohit_te.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_gautami() {
                run_test_bad(INPUT, "telugu/gautami.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_mandali() {
                run_test_bad(INPUT, "telugu/Mandali-Regular.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_nirmala() {
                run_test_bad(INPUT, "indic/Nirmala.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansTelugu-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSerifTelugu-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }
        }

        mod kannada {
            use super::*;

            const INPUT: &str = "bad.kn";
            const SCRIPT_TAG: &str = "knda";
            const LANG_TAG: &str = "KAN";

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "kannada/lohit_kn.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_nirmala() {
                run_test_bad(INPUT, "indic/Nirmala.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansKannada-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSerifKannada-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_tunga() {
                run_test_bad(INPUT, "kannada/tunga.ttf", SCRIPT_TAG, LANG_TAG);
            }
        }

        mod malayalam {
            use super::*;

            const INPUT: &str = "bad.ml";
            const SCRIPT_TAG: &str = "mlym";
            const LANG_TAG: &str = "MAL";

            #[test]
            fn test_lohit() {
                run_test_bad(INPUT, "malayalam/lohit_ml.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_rachana_indic1() {
                run_test_bad(INPUT, "malayalam/Rachana_w01.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_chilanka() {
                run_test_bad(
                    INPUT,
                    "malayalam/Chilanka-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_dyuthi() {
                run_test_bad(INPUT, "malayalam/Dyuthi-Regular.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_nirmala() {
                run_test_bad(INPUT, "indic/Nirmala.ttf", SCRIPT_TAG, LANG_TAG);
            }

            #[test]
            fn test_noto_sans() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSansMalayalam-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test_bad(
                    INPUT,
                    "noto/NotoSerifMalayalam-Regular.ttf",
                    SCRIPT_TAG,
                    LANG_TAG,
                );
            }

            #[test]
            fn test_rachana_indic2() {
                run_test_bad(INPUT, "malayalam/Rachana-Regular.ttf", SCRIPT_TAG, LANG_TAG);
            }
        }
    }
}
